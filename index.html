<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>视频 · 单次评论 · 心形词云</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    /* 基础布局 */
    html, body { height: 100%; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Arial;
      margin: 0;
      background: #fafafa;
      color: #263238;
    }
    #container { max-width: 960px; margin: 0 auto; padding: 24px; }

    /* 视频容器：默认显示 */
    #videoWrap { position: relative; margin-top: 0; display: block; }
    #video { width: 100%; background: #000; border-radius: 12px; }

    /* 视频结束后的居中弹窗：卡片与输入框视觉统一 */
    #overlay {
      position: absolute; inset: 0;
      display: none;
      align-items: center; justify-content: center;
      z-index: 10;
      pointer-events: auto;
    }
    #overlay .card {
      width: min(92%, 560px);
      background: linear-gradient(180deg, #ffffff, #f8fbff);
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(20,30,50,.25);
      padding: 22px 22px 18px;
      border: 1px solid rgba(33,150,243,.12);
    }
    #overlay h3 {
      margin: 4px 0 14px;
      font-size: 22px;
      text-align: center;
      letter-spacing: .5px;
      color: #263238;
    }
    #overlayForm { display: block; }
    #overlay .row { margin-top: 12px; }
    /* 输入框与按钮统一风格 */
    .ui-input, .ui-textarea {
      width: 100%;
      box-sizing: border-box;
      padding: 12px 14px;
      border: 1px solid #dfe7f1;
      border-radius: 12px;
      background: #fff;
      color: #263238;
      box-shadow: 0 1px 0 rgba(0,0,0,.02) inset;
      transition: border-color .2s, box-shadow .2s;
      font-size: 16px;
    }
    .ui-input::placeholder, .ui-textarea::placeholder { color: #8ea6b5; }
    .ui-input:focus, .ui-textarea:focus {
      outline: none;
      border-color: #49a2ff;
      box-shadow: 0 0 0 3px rgba(73,162,255,.15);
    }
    .ui-textarea { min-height: 140px; line-height: 1.6; resize: vertical; }

    .ui-button {
      margin-top: 14px; width: 100%;
      padding: 12px 16px;
      border: none; border-radius: 12px;
      background: linear-gradient(90deg, #2962ff, #3f79ff);
      color: #fff; cursor: pointer; font-weight: 600; letter-spacing: .3px;
      box-shadow: 0 6px 16px rgba(41,98,255,.28);
      font-size: 16px;
    }
    .ui-button:disabled { background: #9db7ff; cursor: not-allowed; box-shadow: none; }

    /* 全屏词云界面：只有词云与背景音乐 */
    #wcPage {
      position: fixed; inset: 0; display: none;
      background: #000; /* 全屏黑色 */
      align-items: center; justify-content: center; flex-direction: column;
      gap: 16px;
    }
    #wcPage .canvasWrap { width: min(92vw, 900px); }
    #wordcloudCanvas {
      display: block; width: 100%; height: 460px;
      border: 1px solid #222; border-radius: 12px;
      background: #000; /* 画布黑底，心形外区域纯黑 */
      box-shadow: 0 12px 30px rgba(0,0,0,.30);
    }
    #bgm { display: none; }
    /* 返回按钮在黑底下的可读性 */
    #wcBack.backBtn {
      position: fixed; top: 16px; left: 16px;
      background: #111; color: #fff;
      border: 1px solid #444; border-radius: 8px;
      padding: 8px 12px; cursor: pointer; z-index: 1000;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="videoWrap">
      <!-- 页面打开即尝试自动播放；muted+playsinline 提升自动播放成功率 -->
      <video id="video" src="video.mp4" autoplay muted playsinline preload="auto" controls></video>

      <!-- 视频结束弹窗（输入框与卡片匹配） -->
      <div id="overlay">
        <div class="card">
          <h3>你觉得爱是什么</h3>
          <form id="overlayForm">
            <div class="row">
              <input id="overlayAuthor" class="ui-input" type="text" placeholder="昵称（可选）" maxlength="128">
            </div>
            <div class="row">
              <textarea id="overlayContent" class="ui-textarea" placeholder="写下你的想法..." maxlength="2000"></textarea>
            </div>
            <button id="overlaySubmit" class="ui-button" type="submit">提交</button>
          </form>
        </div>
      </div>
    </div>
  </div>

  <!-- 全屏词云界面：只显示词云和背景音乐 -->
  <section id="wcPage">
    <button id="wcBack" class="backBtn">返回</button>
    <div class="canvasWrap">
      <canvas id="wordcloudCanvas"></canvas>
    </div>
    <audio id="bgm" src="快速心跳声.mp3" loop></audio>
  </section>

  <script>
    // 基础元素
    const videoWrap = document.getElementById('videoWrap');
    const video = document.getElementById('video');

    const overlay = document.getElementById('overlay');
    const overlayForm = document.getElementById('overlayForm');
    const overlayAuthorEl = document.getElementById('overlayAuthor');
    const overlayContentEl = document.getElementById('overlayContent');
    const overlaySubmitBtn = document.getElementById('overlaySubmit');

    // 词云界面
    const wcPage = document.getElementById('wcPage');
    const wcCanvas = document.getElementById('wordcloudCanvas');
    const bgm = document.getElementById('bgm');
    const wcBack = document.getElementById('wcBack');

    // 线程与“仅一次”标记
    const thread = (location.pathname.replace(/[^a-z0-9/_-]/gi, '_') || '/').toLowerCase();
    const submittedKey = 'submitted:' + thread;

    // 页面加载后再尝试播放（进一步提升自动播放成功率）
    document.addEventListener('DOMContentLoaded', () => {
      video.play().catch(() => {});
    });

    // 视频结束：显示弹窗（只能一次）
    video.addEventListener('ended', () => {
      overlay.style.display = 'flex';
      if (localStorage.getItem(submittedKey) === '1') {
        overlayAuthorEl.disabled = true;
        overlayContentEl.disabled = true;
        overlaySubmitBtn.disabled = true;
      }
    });

    // 弹窗提交：成功后进入“全屏词云界面”
    overlayForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const author = overlayAuthorEl.value.trim();
      const content = overlayContentEl.value.trim();
      if (!content) { alert('内容不能为空'); return; }
      overlaySubmitBtn.disabled = true;
      try {
        const at = Math.floor(video.currentTime || 0);
        const resp = await fetch('/comments', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ thread, author, content, at_seconds: at })
        });
        const data = await resp.json();
        if (!resp.ok || !data.ok) throw new Error(data.error || '提交失败');

        // 标记仅一次
        localStorage.setItem(submittedKey, '1');

        // 切换到词云全屏界面
        overlay.style.display = 'none';
        document.getElementById('container').style.display = 'none';
        wcPage.style.display = 'flex';

        await genWordCloud(true);
        bgm.currentTime = 0;
        bgm.play().catch(() => {});
      } catch (err) {
        alert('提交失败：' + (err.message || err));
      } finally {
        overlaySubmitBtn.disabled = false;
      }
    });

    // 词云界面“返回”：暂停 BGM，隐藏词云，回到视频界面
    wcBack.addEventListener('click', () => {
      try { bgm.pause(); } catch {}
      wcPage.style.display = 'none';
      const container = document.getElementById('container');
      container.style.display = 'block';
      videoWrap.style.display = 'block';
      overlay.style.display = 'none'; // 保持只能一次，不再显示弹窗
      // 如果需要返回后继续播放视频，可取消注释：
      // video.play().catch(() => {});
    });

    // 生成词云（优先使用透明 PNG；不存在则回退到 JPG；仅在红色心形内排布）
    async function genWordCloud(auto = false) {
      const tokens = await collectTokensFromAllComments();
      await renderWordCloudMask(tokens);
    }

    // 拉取全部评论并统计词频
    async function collectTokensFromAllComments() {
      let wcOffset = 0;
      const wcLimit = 100;
      const texts = [];
      while (true) {
        const resp = await fetch(`/comments?thread=${encodeURIComponent(thread)}&limit=${wcLimit}&offset=${wcOffset}`);
        const data = await resp.json();
        if (!resp.ok || !data.ok) throw new Error(data.error || '拉取失败');
        if (data.items.length === 0) break;
        texts.push(...data.items.map(i => String(i.content || '')));
        wcOffset += data.items.length;
        if (data.items.length < wcLimit) break;
      }
      return buildFrequencies(texts);
    }

    // 简易中文友好分词：英文按词、中文双字滑窗
    function buildFrequencies(texts) {
      const stop = new Set(['的','了','是','我','你','他','她','它','在','和','与','就','都','很','也','这','那','一个','我们','他们','因为','所以','如果','但是','而且','不是','还有','会','能','把','被','给','让','呢','嘛','吗','啊','哦','呃']);
      const freq = new Map();
      const normalize = s => s.toLowerCase().replace(/[^\p{L}\p{N}\u4e00-\u9fff]+/gu, ' ');
      const add = w => { if (!w || stop.has(w) || w.length < 2) return; freq.set(w, (freq.get(w) || 0) + 1); };
      for (const t of texts) {
        const s = normalize(t);
        const words = s.match(/\p{L}[\p{L}\p{N}_]{1,}/gu) || [];
        words.forEach(add);
        const zhSeqs = s.match(/[\u4e00-\u9fff]+/g) || [];
        zhSeqs.forEach(seq => {
          if (seq.length >= 2) for (let i = 0; i < seq.length - 1; i++) add(seq.slice(i, i + 2));
        });
      }
      const arr = Array.from(freq.entries()).map(([word, count]) => ({ word, count }));
      arr.sort((a, b) => b.count - a.count);
      return arr.slice(0, 120);
    }

    // 加载图片（PNG 优先，JPG 作为回退）
    async function loadMaskImage() {
      try { return await loadImage('心跳.png'); } catch {}
      return await loadImage('心跳.jpg');
    }
    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src;
      });
    }

    // 心形掩模渲染：PNG 透明背景或 JPG 的红色识别
    async function renderWordCloudMask(tokens) {
      const canvas = wcCanvas;
      const ctx = canvas.getContext('2d');
      const W = Math.round(Math.min(window.innerWidth * 0.92, 900));
      const H = 460;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.round(W * dpr);
      canvas.height = Math.round(H * dpr);
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      /* 黑色背景 */
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      /* 生成心形掩模（透明 PNG 优先，否则对 JPG 做红色识别） */
      const img = await loadMaskImage();
      const off = document.createElement('canvas');
      off.width = W; off.height = H;
      const ictx = off.getContext('2d');
      ictx.drawImage(img, 0, 0, W, H);
      const { data } = ictx.getImageData(0, 0, W, H);

      let mask = makeAlphaOrRedMask(data, W, H);
      mask = closeMask(mask, W, H, 2);

      const inside = (x, y) => x >= 0 && y >= 0 && x < W && y < H && mask[y * W + x] === 1;

      /* 碰撞格子避免重叠 + 覆盖率统计（尽量填满形状） */
      const cell = 16; /* 略小格子，提升可填充细缝能力 */
      const cols = Math.ceil(W / cell), rows = Math.ceil(H / cell);
      const grid = Array.from({ length: rows }, () => Array(cols).fill(0));
      const covered = Array.from({ length: rows }, () => Array(cols).fill(0));

      // 统计心形区域的格子数量（用于覆盖率）
      let shapeCells = 0;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const cx = Math.floor(c * cell + cell / 2);
          const cy = Math.floor(r * cell + cell / 2);
          if (inside(cx, cy)) shapeCells++;
        }
      }

      const occupy = (x, y, w, h) => {
        const c0 = Math.max(0, Math.floor(x / cell)), r0 = Math.max(0, Math.floor(y / cell));
        const c1 = Math.min(cols - 1, Math.floor((x + w) / cell)), r1 = Math.min(rows - 1, Math.floor((y + h) / cell));
        for (let r = r0; r <= r1; r++) for (let c = c0; c <= c1; c++) if (grid[r][c]) return false;
        for (let r = r0; r <= r1; r++) for (let c = c0; c <= c1; c++) grid[r][c] = 1;
        // 标记覆盖率
        for (let r = r0; r <= r1; r++) for (let c = c0; c <= c1; c++) covered[r][c] = 1;
        return true;
      };
      const coverageRatio = () => {
        let coveredCells = 0;
        for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) if (covered[r][c]) coveredCells++;
        return shapeCells ? coveredCells / shapeCells : 0;
      };

      /* 字体鲜红色，增大字号范围 */
      const brightRed = '#FF2B2B';
      const max = tokens.length ? tokens[0].count : 1;
      const min = tokens.length ? tokens[tokens.length - 1].count : 1;
      const fontSize = c => {
        const t = (c - min) / Math.max(1, (max - min));
        return Math.round(18 + t * 50); /* 18px ~ 68px 更大 */
      };

      function sampleInside() {
        for (let k = 0; k < 800; k++) {
          const x = Math.floor(Math.random() * W);
          const y = Math.floor(Math.random() * H);
          if (inside(x, y)) return { x, y };
        }
        return { x: Math.floor(W / 2), y: Math.floor(H / 2) };
      }

      /* 第一阶段：按词频从大到小布局（偏向中心） */
      tokens.sort((a, b) => b.count - a.count);
      tokens.forEach((t, i) => {
        const size = fontSize(t.count);
        ctx.font = `bold ${size}px system-ui, -apple-system, Segoe UI, Arial`;
        const text = t.word;
        const w = Math.ceil(ctx.measureText(text).width);
        const h = Math.ceil(size * 1.2);

        const bias = Math.min(0.85, 0.55 + i / tokens.length * 0.3); /* 大词更中心 */
        let placed = false;
        for (let tries = 0; tries < 220 && !placed; tries++) {
          const p = sampleInside();
          const x = Math.round(p.x - w / 2);
          const y = Math.round(p.y - h / 2);
          if (x < 0 || y < 0 || x + w >= W || y + h >= H) continue;
          if (!inside(p.x, p.y) || !inside(x, y) || !inside(x + w, y) || !inside(x, y + h) || !inside(x + w, y + h)) continue;
          if (!occupy(x, y, w, h)) continue;
          ctx.fillStyle = brightRed;
          ctx.fillText(text, x, y + h * 0.8);
          placed = true;
        }
      });

      /* 第二阶段：重复高频词并用小字号填缝，尽量提高覆盖率 */
      const target = 0.92; /* 目标覆盖率，尽量填满 */
      const topWords = tokens.slice(0, Math.min(12, tokens.length)).map(t => t.word);
      let fillRounds = 0;
      while (coverageRatio() < target && fillRounds < 6) {
        for (let k = 0; k < topWords.length; k++) {
          const text = topWords[k];
          const size = Math.max(14, 20 - fillRounds * 2); /* 逐步减小以填缝（不低于14） */
          ctx.font = `bold ${size}px system-ui, -apple-system, Segoe UI, Arial`;
          const w = Math.ceil(ctx.measureText(text).width);
          const h = Math.ceil(size * 1.2);
          let placed = false;
          for (let tries = 0; tries < 180 && !placed; tries++) {
            const p = sampleInside();
            const x = Math.round(p.x - w / 2);
            const y = Math.round(p.y - h / 2);
            if (x < 0 || y < 0 || x + w >= W || y + h >= H) continue;
            if (!inside(p.x, p.y) || !inside(x, y) || !inside(x + w, y) || !inside(x, y + h) || !inside(x + w, y + h)) continue;
            if (!occupy(x, y, w, h)) continue;
            ctx.fillStyle = brightRed;
            ctx.fillText(text, x, y + h * 0.8);
            placed = true;
          }
        }
        fillRounds++;
        /* 防止无限循环：若已经很难再放下，跳出 */
        if (fillRounds >= 6) break;
      }
    }

    // 透明优先/红色回退的掩模
    function makeAlphaOrRedMask(data, W, H) {
      // 检测是否存在显著透明：如果大面积透明则直接用 alpha 作为外部
      let alphaZeroCount = 0;
      for (let i = 3; i < data.length; i += 4) if (data[i] < 10) alphaZeroCount++;
      const hasTransparent = alphaZeroCount > (data.length / 4) * 0.05;

      const mask = new Uint8Array(W * H);
      for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
          const i = (y * W + x) * 4;
          const r = data[i], g = data[i + 1], b = data[i + 2], a = data[i + 3];
          let inside = false;
          if (hasTransparent) {
            // 透明背景 PNG：alpha>=40 视为形状内
            inside = a >= 40;
          } else {
            // JPG（黑底红心）：仅识别红色像素为形状内
            const redness = r - Math.max(g, b);
            const isRed = (a >= 10 && r >= 150 && redness >= 50 && g <= 140 && b <= 140);
            inside = isRed;
          }
          mask[y * W + x] = inside ? 1 : 0;
        }
      }
      return mask;
    }

    // 形态学闭运算：膨胀后腐蚀
    function closeMask(mask, W, H, radius = 2) {
      return erode(dilate(mask, W, H, radius), W, H, radius);
    }
    function dilate(mask, W, H, radius) {
      const out = new Uint8Array(mask.length);
      for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
          let v = 0;
          for (let dy = -radius; dy <= radius && !v; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
              const yy = y + dy, xx = x + dx;
              if (yy >= 0 && yy < H && xx >= 0 && xx < W) { if (mask[yy * W + xx]) { v = 1; break; } }
            }
          }
          out[y * W + x] = v;
        }
      }
      return out;
    }
    function erode(mask, W, H, radius) {
      const out = new Uint8Array(mask.length);
      for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
          let v = 1;
          for (let dy = -radius; dy <= radius && v; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
              const yy = y + dy, xx = x + dx;
              if (yy < 0 || yy >= H || xx < 0 || xx >= W || !mask[yy * W + xx]) { v = 0; break; }
            }
          }
          out[y * W + x] = v;
        }
      }
      return out;
    }
  </script>
</body>
</html>