<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>心跳词云</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="color-scheme" content="dark light" />
  <style>
    :root {
      --black: #000;
      --white: #fff;
      --card-bg: rgba(15, 15, 20, 0.85);
      --card-border: rgba(255, 255, 255, 0.08);
      --input-bg: rgba(20, 20, 25, 0.9);
      --input-border: rgba(255, 255, 255, 0.12);
      --input-focus: #6a9cff;
      --red: #FF2B2B;
      --muted: #aaa;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; background: var(--black); color: var(--white); margin: 0; font-family: system-ui, -apple-system, "Segoe UI", Arial, "Noto Sans SC", "PingFang SC", "Microsoft YaHei", sans-serif; }

    /* 视频页：铺满屏幕 */
    #videoPage {
      position: fixed; inset: 0;
      display: flex; align-items: center; justify-content: center;
      background: #000;
    }
    .videoWrap {
      position: relative;
      width: 100vw; height: 100vh;
      overflow: hidden;
      background: #000;
    }
    #mainVideo {
      width: 100%; height: 100%;
      object-fit: cover;
      display: block;
      background: #000;
    }

    /* 评论弹窗卡片与输入框：统一视觉 */
    .commentCard {
      position: absolute; left: 50%; transform: translateX(-50%);
      bottom: 6vh;
      width: min(680px, 92vw);
      background: var(--card-bg);
      backdrop-filter: blur(10px);
      border: 1px solid var(--card-border);
      border-radius: 16px;
      padding: 18px 16px;
      box-shadow: 0 8px 40px rgba(0, 0, 0, 0.45);
      display: none; /* 视频结束后显示 */
    }
    .commentCard .cardTitle {
      font-weight: 600; font-size: 16px; margin: 0 0 10px; color: var(--white);
    }
    .commentForm {
      display: flex; gap: 10px; align-items: center;
    }
    .commentForm input[type="text"] {
      flex: 1;
      padding: 12px 14px;
      font-size: 16px; line-height: 22px;
      color: var(--white); background: var(--input-bg);
      border: 1px solid var(--input-border); border-radius: 12px;
      outline: none;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .commentForm input[type="text"]::placeholder { color: var(--muted); }
    .commentForm input[type="text"]:focus {
      border-color: var(--input-focus);
      box-shadow: 0 0 0 4px rgba(106, 156, 255, 0.12);
    }
    .commentForm button {
      padding: 12px 16px;
      font-weight: 600; font-size: 15px;
      color: #fff; background: #2459F0;
      border: none; border-radius: 12px; cursor: pointer;
      transition: filter 0.2s ease, transform 0.02s ease;
    }
    .commentForm button:hover { filter: brightness(1.1); }
    .commentForm button:active { transform: scale(0.99); }
    .cardHint { margin-top: 8px; font-size: 12px; color: var(--muted); }

    /* 词云界面：黑底 + 全屏画布，仅显示词云与背景音乐（按钮） */
    #wcPage {
      position: fixed; inset: 0; display: none;
      background: #000;
      align-items: center; justify-content: center; flex-direction: column;
    }
    #wcPage .canvasWrap {
      width: 100vw; height: 100vh;
    }
    #wordcloudCanvas {
      display: block; width: 100%; height: 100%;
      border: 0; border-radius: 0;
      background: #000; /* 画布黑底（形状外区域纯黑） */
      box-shadow: none;
    }
    /* 返回按钮（仅词云页存在） */
    #wcBack.backBtn {
      position: fixed; top: 16px; left: 16px;
      background: #111; color: #fff;
      border: 1px solid #444; border-radius: 10px;
      padding: 8px 14px; cursor: pointer; z-index: 1000;
      font-size: 14px; font-weight: 600;
    }
    #wcBack.backBtn:hover { filter: brightness(1.12); }
    #wcBack.backBtn:active { transform: scale(0.98); }
  </style>
</head>
<body>
  <!-- 视频播放界面 -->
  <section id="videoPage">
    <div class="videoWrap">
      <video id="mainVideo"
             src="video.mp4"
             muted
             playsinline
             webkit-playsinline
             preload="auto"
             autoplay
             poster=""
      ></video>

      <!-- 评论弹窗（视频结束后显示） -->
      <div id="commentCard" class="commentCard" role="dialog" aria-modal="true">
        <h3 class="cardTitle">写下你的心声</h3>
        <form id="commentForm" class="commentForm">
          <input id="commentInput" type="text" maxlength="300" placeholder="在此输入（提交后将生成红色心形词云）" />
          <button id="submitBtn" type="submit">提交</button>
        </form>
        <div class="cardHint">提交后将进入全屏词云界面播放心跳背景音乐。</div>
      </div>
    </div>
  </section>

  <!-- 词云界面：只显示词云画布与返回按钮，播放背景音乐 -->
  <section id="wcPage">
    <button id="wcBack" class="backBtn" type="button">返回</button>
    <div class="canvasWrap">
      <canvas id="wordcloudCanvas"></canvas>
    </div>
    <audio id="bgm" src="快速心跳声.mp3" preload="auto" loop></audio>
  </section>

  <script>
    // 元素引用
    const video = document.getElementById('mainVideo');
    const commentCard = document.getElementById('commentCard');
    const commentForm = document.getElementById('commentForm');
    const commentInput = document.getElementById('commentInput');
    const wcPage = document.getElementById('wcPage');
    const wcBack = document.getElementById('wcBack');
    const wcCanvas = document.getElementById('wordcloudCanvas');
    const bgm = document.getElementById('bgm');

    // 进入页面即尝试自动播放视频
    document.addEventListener('DOMContentLoaded', async () => {
      try {
        await video.play();
      } catch (e) {
        // 某些浏览器需用户手势；保持静音与自动播放属性
        console.warn('自动播放受限：', e);
      }
    });

    // 视频结束后显示评论弹窗
    video.addEventListener('ended', () => {
      showCommentCard();
    });

    function showCommentCard() {
      commentCard.style.display = 'block';
      commentInput.focus();
    }
    function hideCommentCard() {
      commentCard.style.display = 'none';
    }

    // 提交评论后：POST 后端，切换到词云界面并渲染词云
    commentForm.addEventListener('submit', async (ev) => {
      ev.preventDefault();
      const content = (commentInput.value || '').trim();
      if (!content) {
        commentInput.focus();
        return;
      }
      try {
        await postComment(content);
      } catch (err) {
        console.error('提交评论失败：', err);
        // 即使失败也进入词云界面，避免交互卡住
      }
      hideCommentCard();
      goWordCloudPage();
      try {
        await renderWordCloud(content);
      } catch (e) {
        console.error('渲染词云失败：', e);
      }
    });

    // 返回按钮：仅词云界面存在；返回视频界面并暂停背景音乐
    wcBack.addEventListener('click', async () => {
      try { bgm.pause(); bgm.currentTime = 0; } catch {}
      wcPage.style.display = 'none';
      // 回到视频播放界面；不显示评论卡片
      try {
        video.muted = true;
        await video.play();
      } catch (e) {
        console.warn('返回后视频自动播放受限：', e);
      }
    });

    // 进入词云界面并播放背景音乐
    function goWordCloudPage() {
      wcPage.style.display = 'flex';
      try { bgm.play(); } catch (e) { console.warn('BGM 播放受限：', e); }
    }

    // 提交评论到后端（Neon + Render）
    async function postComment(content) {
      const atSeconds = Math.floor(video.currentTime || 0);
      const payload = {
        thread: 'main',
        author: '游客',
        content,
        at_seconds: atSeconds,
      };
      const res = await fetch('/comments', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(`HTTP ${res.status}: ${text}`);
      }
      const data = await res.json().catch(() => ({}));
      console.log('评论已提交：', { payload, data });
      return data;
    }

    // 渲染词云：收集 tokens -> 掩模 -> 布局
    async function renderWordCloud(userText) {
      // 准备画布为全屏 + DPR
      const canvas = wcCanvas;
      const ctx = canvas.getContext('2d');
      const W = Math.max(1, Math.floor(window.innerWidth));
      const H = Math.max(1, Math.floor(window.innerHeight));
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.round(W * dpr);
      canvas.height = Math.round(H * dpr);
      canvas.style.width = '100vw';
      canvas.style.height = '100vh';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // 黑色背景
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      // 收集 tokens：优先从后端评论聚合；为空则回退到用户输入
      let tokens = [];
      try {
        const comments = await fetchComments();
        tokens = buildTokensFromTexts(comments.map(c => c.content || ''));
      } catch (e) {
        console.warn('拉取评论失败，回退到用户输入：', e);
      }
      if (!tokens.length) {
        tokens = buildTokensFromTexts([userText || '心跳 爱 情感 希望 勇气']);
      }

      // 渲染带掩模的词云
      await renderWordCloudMask(tokens);
    }

    // 拉取评论（最多 100 条）
    async function fetchComments() {
      const res = await fetch('/comments?thread=main&limit=100');
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res.json();
    }

    // 从文本数组构建词频 tokens
    function buildTokensFromTexts(texts) {
      const map = new Map();
      for (const text of texts) {
        const t = String(text);
        // 英文/数字词
        const latin = t.toLowerCase().match(/[a-z0-9]+/g) || [];
        for (const w of latin) {
          const k = w;
          map.set(k, (map.get(k) || 0) + 1);
        }
        // 中文：以字符为单位（保证形状填充），可按需改为2-3字词
        for (const ch of t) {
          const code = ch.codePointAt(0);
          if (code >= 0x4E00 && code <= 0x9FFF) {
            map.set(ch, (map.get(ch) || 0) + 1);
          }
        }
      }
      // 转为数组并排序
      const arr = Array.from(map.entries()).map(([word, count]) => ({ word, count }));
      arr.sort((a, b) => b.count - a.count);
      // 至少留一些高频词，便于重复填充
      return arr.slice(0, Math.max(50, Math.min(arr.length, 300)));
    }

    // 载入掩模图片，优先透明 PNG，否则使用 JPG
    async function loadMaskImage() {
      const preferList = ['心跳.png', '心跳.jpg'];
      for (const src of preferList) {
        try {
          const img = await loadImage(src);
          return img;
        } catch {}
      }
      throw new Error('未找到掩模图片（心跳.png 或 心跳.jpg）');
    }

    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src + '?t=' + Date.now(); // 防缓存
      });
    }

    // 将图片按 contain 居中绘制到目标画布
    function drawContain(ictx, img, W, H) {
      const iw = img.naturalWidth || img.width;
      const ih = img.naturalHeight || img.height;
      const scale = Math.min(W / iw, H / ih);
      const dw = Math.max(1, Math.floor(iw * scale));
      const dh = Math.max(1, Math.floor(ih * scale));
      const dx = Math.floor((W - dw) / 2);
      const dy = Math.floor((H - dh) / 2);
      ictx.clearRect(0, 0, W, H);
      ictx.drawImage(img, dx, dy, dw, dh);
    }

    // 使用 alpha 或红色识别生成掩模；并闭运算平滑边界
    async function renderWordCloudMask(tokens) {
      const canvas = wcCanvas;
      const ctx = canvas.getContext('2d');
      const W = Math.max(1, Math.floor(window.innerWidth));
      const H = Math.max(1, Math.floor(window.innerHeight));
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.round(W * dpr);
      canvas.height = Math.round(H * dpr);
      canvas.style.width = '100vw';
      canvas.style.height = '100vh';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // 黑色背景（形状外区域保持纯黑）
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      // 掩模生成
      const img = await loadMaskImage();
      const off = document.createElement('canvas');
      off.width = W; off.height = H;
      const ictx = off.getContext('2d');
      drawContain(ictx, img, W, H);
      const imgData = ictx.getImageData(0, 0, W, H);
      let mask = makeAlphaOrRedMask(imgData.data, W, H);
      mask = closeMask(mask, W, H, 2);

      const inside = (x, y) => x >= 0 && y >= 0 && x < W && y < H && mask[y * W + x] === 1;

      // 提取边缘点并勾勒淡红色轮廓，增强形状感
      const edgePts = buildEdgePoints(mask, W, H, 2, 3);
      drawMaskOutline(edgePts, ctx);

      // 碰撞格子与覆盖率统计
      const cell = 16;
      const cols = Math.ceil(W / cell), rows = Math.ceil(H / cell);
      const grid = Array.from({ length: rows }, () => Array(cols).fill(0));
      const covered = Array.from({ length: rows }, () => Array(cols).fill(0));

      let shapeCells = 0;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const cx = Math.floor(c * cell + cell / 2);
          const cy = Math.floor(r * cell + cell / 2);
          if (inside(cx, cy)) shapeCells++;
        }
      }
      const occupy = (x, y, w, h) => {
        const c0 = Math.max(0, Math.floor(x / cell)), r0 = Math.max(0, Math.floor(y / cell));
        const c1 = Math.min(cols - 1, Math.floor((x + w) / cell)), r1 = Math.min(rows - 1, Math.floor((y + h) / cell));
        for (let r = r0; r <= r1; r++) for (let c = c0; c <= c1; c++) if (grid[r][c]) return false;
        for (let r = r0; r <= r1; r++) for (let c = c0; c <= c1; c++) grid[r][c] = 1, covered[r][c] = 1;
        return true;
      };
      const coverageRatio = () => {
        let cov = 0;
        for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) if (covered[r][c]) cov++;
        return shapeCells ? cov / shapeCells : 0;
      };

      // 明亮红色与字号范围
      const brightRed = '#FF2B2B';
      const max = tokens.length ? tokens[0].count : 1;
      const min = tokens.length ? tokens[tokens.length - 1].count : 1;
      const fontSize = c => {
        const t = (c - min) / Math.max(1, (max - min));
        return Math.round(18 + t * 50); // 18px ~ 68px
      };

      function sampleInside() {
        for (let k = 0; k < 800; k++) {
          const x = Math.floor(Math.random() * W);
          const y = Math.floor(Math.random() * H);
          if (inside(x, y)) return { x, y };
        }
        return { x: Math.floor(W / 2), y: Math.floor(H / 2) };
      }
      function sampleEdge() {
        if (!edgePts.length) return sampleInside();
        return edgePts[Math.floor(Math.random() * edgePts.length)];
      }

      // 阶段1：高频词优先，居中倾向布局
      tokens.sort((a, b) => b.count - a.count);
      tokens.forEach((t, i) => {
        const size = fontSize(t.count);
        ctx.font = `bold ${size}px system-ui, -apple-system, Segoe UI, Arial`;
        const text = t.word;
        const w = Math.ceil(ctx.measureText(text).width);
        const h = Math.ceil(size * 1.2);

        let placed = false;
        for (let tries = 0; tries < 220 && !placed; tries++) {
          const p = sampleInside();
          const x = Math.round(p.x - w / 2);
          const y = Math.round(p.y - h / 2);
          if (x < 0 || y < 0 || x + w >= W || y + h >= H) continue;
          // 文本框四角需在形状内
          if (!inside(p.x, p.y) || !inside(x, y) || !inside(x + w, y) || !inside(x, y + h) || !inside(x + w, y + h)) continue;
          if (!occupy(x, y, w, h)) continue;
          ctx.fillStyle = brightRed;
          ctx.fillText(text, x, y + h * 0.8);
          placed = true;
        }
      });

      // 阶段2：贴边填充，小字号沿边界排布，突出心形轮廓
      const edgeWords = tokens.slice(0, Math.min(20, tokens.length)).map(t => t.word);
      for (let round = 0; round < 3; round++) {
        edgeWords.forEach(text => {
          const size = Math.max(16, 22 - round * 2);
          ctx.font = `bold ${size}px system-ui, -apple-system, Segoe UI, Arial`;
          const w = Math.ceil(ctx.measureText(text).width);
          const h = Math.ceil(size * 1.2);
          let placed = false;
          for (let tries = 0; tries < 160 && !placed; tries++) {
            const p = sampleEdge();
            const x = Math.round(p.x - w / 2);
            const y = Math.round(p.y - h / 2);
            if (x < 0 || y < 0 || x + w >= W || y + h >= H) continue;
            if (!inside(p.x, p.y) || !inside(x, y) || !inside(x + w, y) || !inside(x, y + h) || !inside(x + w, y + h)) continue;
            if (!occupy(x, y, w, h)) continue;
            ctx.fillStyle = brightRed;
            ctx.fillText(text, x, y + h * 0.8);
            placed = true;
          }
        });
        if (coverageRatio() >= 0.92) break;
      }

      // 阶段3：覆盖率不足则重复高频词小字号补缝
      const target = 0.95;
      const topWords = tokens.slice(0, Math.min(12, tokens.length)).map(t => t.word);
      let rounds = 0;
      while (coverageRatio() < target && rounds < 6) {
        for (const text of topWords) {
          const size = Math.max(14, 20 - rounds * 2);
          ctx.font = `bold ${size}px system-ui, -apple-system, Segoe UI, Arial`;
          const w = Math.ceil(ctx.measureText(text).width);
          const h = Math.ceil(size * 1.2);
          let placed = false;
          for (let tries = 0; tries < 160 && !placed; tries++) {
            const p = sampleInside();
            const x = Math.round(p.x - w / 2);
            const y = Math.round(p.y - h / 2);
            if (x < 0 || y < 0 || x + w >= W || y + h >= H) continue;
            if (!inside(p.x, p.y) || !inside(x, y) || !inside(x + w, y) || !inside(x, y + h) || !inside(x + w, y + h)) continue;
            if (!occupy(x, y, w, h)) continue;
            ctx.fillStyle = brightRed;
            ctx.fillText(text, x, y + h * 0.8);
            placed = true;
          }
        }
        rounds++;
      }
    }
  
    // 掩模边缘点提取：掩模内且邻域存在外部像素
    function buildEdgePoints(mask, W, H, radius = 2, step = 3) {
      const pts = [];
      for (let y = radius; y < H - radius; y += step) {
        for (let x = radius; x < W - radius; x += step) {
          const i = y * W + x;
          if (mask[i] !== 1) continue;
          let nearOutside = false;
          for (let dy = -radius; dy <= radius && !nearOutside; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
              const yy = y + dy, xx = x + dx;
              if (yy < 0 || yy >= H || xx < 0 || xx >= W) continue;
              if (mask[yy * W + xx] === 0) { nearOutside = true; break; }
            }
          }
          if (nearOutside) pts.push({ x, y });
        }
      }
      return pts;
    }
  
    // 轮廓描边：轻微透明红点勾勒边界，提高形状可读性
    function drawMaskOutline(edgePts, ctx) {
      ctx.save();
      ctx.fillStyle = '#FF2B2B';
      ctx.globalAlpha = 0.12;
      for (const p of edgePts) ctx.fillRect(p.x, p.y, 2, 2);
      ctx.restore();
    }
  
    // 基于 alpha 或红色识别掩模
    function makeAlphaOrRedMask(data, W, H) {
      const n = W * H;
      const mask = new Uint8Array(n);
      let hasTransparent = false;
      for (let i = 0; i < n; i++) {
        const a = data[i * 4 + 3];
        if (a < 250) { hasTransparent = true; break; }
      }
      if (hasTransparent) {
        // 透明 PNG：alpha > 阈值视为形状
        const ath = 25;
        for (let i = 0; i < n; i++) {
          const a = data[i * 4 + 3];
          mask[i] = a > ath ? 1 : 0;
        }
      } else {
        // JPG：红色识别
        const rth = 110, gap = 50;
        for (let i = 0; i < n; i++) {
          const r = data[i * 4 + 0], g = data[i * 4 + 1], b = data[i * 4 + 2];
          const isRed = r > rth && (r - Math.max(g, b)) > gap;
          mask[i] = isRed ? 1 : 0;
        }
      }
      return mask;
      // 注意：调用方会做闭运算平滑边界
    }
  
    // 形态学闭运算（膨胀后腐蚀）以填平细小空洞
    function closeMask(mask, W, H, radius = 2) {
      return erode(dilate(mask, W, H, radius), W, H, radius);
    }
    function dilate(mask, W, H, r = 1) {
      const out = new Uint8Array(W * H);
      for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
        let v = 0;
        for (let dy = -r; dy <= r && !v; dy++) {
          for (let dx = -r; dx <= r; dx++) {
            const yy = y + dy, xx = x + dx;
            if (yy < 0 || yy >= H || xx < 0 || xx >= W) continue;
            if (mask[yy * W + xx]) { v = 1; break; }
          }
        }
        out[y * W + x] = v;
      }
      return out;
    }
    function erode(mask, W, H, r = 1) {
      const out = new Uint8Array(W * H);
      for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
        let v = 1;
        for (let dy = -r; dy <= r && v; dy++) {
          for (let dx = -r; dx <= r; dx++) {
            const yy = y + dy, xx = x + dx;
            if (yy < 0 || yy >= H || xx < 0 || xx >= W) continue;
            if (!mask[yy * W + xx]) { v = 0; break; }
          }
        }
        out[y * W + x] = v;
      }
      return out;
    }
  </script>
</body>
</html>