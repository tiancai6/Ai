<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>è§†é¢‘å¼¹å¹•è¯„è®ºï¼ˆRender + Neonï¼‰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Arial; margin: 40px; background:#fafafa; }
    #container { max-width: 900px; margin: 0 auto; }
    #playBtn { font-size: 18px; padding: 10px 20px; }

    #videoWrap { position: relative; margin-top: 20px; display:none; }
    #video { width: 100%; background:#000; }
    #danmakuLayer { position:absolute; inset:0; pointer-events:none; overflow:hidden; }
    .dm { position:absolute; right:-20%; color:#fff; font-weight:600; text-shadow: 1px 1px 2px #000;
          white-space:nowrap; will-change:transform, opacity; animation: dm-move linear 8s forwards; }
    @keyframes dm-move {
      0% { transform: translateX(0); opacity: 1; }
      90% { opacity: 1; }
      100% { transform: translateX(-140%); opacity: 0; }
    }

    /* è§†é¢‘ç»“æŸåçš„å±…ä¸­å¼¹çª— */
    #overlay { position:absolute; inset:0; display:none; align-items:center; justify-content:center; z-index:10; }
    #overlay .card {
      width: min(90%, 520px);
      background:#fff;
      border-radius:12px;
      box-shadow:0 8px 30px rgba(0,0,0,.3);
      padding: 20px;
    }
    #overlay h3 { margin: 0 0 12px; font-size: 20px; text-align:center; }
    #overlay .row { display:flex; gap:12px; margin-top: 12px; }
    #overlay input, #overlay textarea, #overlay button { font-size: 16px; }
    #overlay textarea { min-height: 120px; }
    #overlay button { margin-top: 12px; width: 100%; }

    /* æ™®é€šè¡¨å•ä¸åˆ—è¡¨ï¼ˆä»…éšè—åº•éƒ¨å¸¸è§„è¡¨å•ï¼‰ */
    #commentForm { display:none; gap:12px; margin: 16px 0; }
    input, textarea, button { font-size: 16px; }
    input, textarea { padding: 10px; border:1px solid #ddd; border-radius:8px; flex:1; }
    textarea { min-height: 100px; }
    button { padding: 10px 16px; border: none; border-radius: 8px; background: #2962ff; color:#fff; cursor:pointer; }
    button:disabled { background:#999; cursor:not-allowed; }

    /* å¼¹çª—è¦†ç›–å±‚ï¼šç¡®ä¿å¯ç‚¹å‡» */
    #overlay { position:absolute; inset:0; display:none; align-items:center; justify-content:center; z-index:10; pointer-events:auto; }
    #overlay .card {
      width: min(90%, 520px);
      background:#fff;
      border-radius:12px;
      box-shadow:0 8px 30px rgba(0,0,0,.3);
      padding: 20px;
    }
    #overlay h3 { margin: 0 0 12px; font-size: 20px; text-align:center; }
    #overlay .row { display:flex; gap:12px; margin-top: 12px; }
    /* æ˜¾ç¤ºå¼¹çª—è¡¨å•ï¼ˆå–æ¶ˆè¢«å…¨å±€éšè—çš„å½±å“ï¼‰ */
    #overlayForm { display:block; }
    #overlay textarea { min-height: 120px; }
    #overlay button { margin-top: 12px; width: 100%; }

    #status { color:#666; margin-top:12px; }
    #list .item { border-bottom:1px solid #eee; padding:12px 0; }
    .meta { color:#666; font-size:14px; }
    .content { white-space: pre-wrap; }

    /* ç‚¹èµæŒ‰é’®æ ·å¼ */
    .likeBtn {
      margin-left: 12px;
      font-size: 14px;
      padding: 2px 8px;
      border: 1px solid #ddd;
      border-radius: 14px;
      background: #fff;
      color: #333;
      cursor: pointer;
    }
    .likeBtn[disabled] {
      opacity: 0.6;
      cursor: default;
    }

    /* é¦–æ¬¡è®¿é—®ï¼šéšè—è¯„è®ºåˆ—è¡¨ä¸â€œåŠ è½½æ›´å¤šâ€ */
    #list, #moreBtn { display: none; }
    /* è¯äº‘å®¹å™¨ä¸è¯æ¡æ ·å¼ */
    #wordcloud { display:none; border: 1px solid #eee; border-radius: 8px; padding: 12px; background:#fff; margin-top:12px; }
    #wordcloud .token { display:inline-block; margin:6px 8px; padding:2px 4px; border-radius:4px; background:#f5f7ff; color:#333; }
  </style>
</head>
<body>
  <div id="container">
    <button id="playBtn">æ’­æ”¾</button>

    <div id="videoWrap">
      <video id="video" src="video.mp4" controls></video>
      <div id="danmakuLayer"></div>

      <!-- è§†é¢‘ç»“æŸåçš„å±…ä¸­å¼¹çª— -->
      <div id="overlay">
        <div class="card">
          <h3>ä½ è§‰å¾—çˆ±æ˜¯ä»€ä¹ˆ</h3>
          <form id="overlayForm">
            <div class="row">
              <input id="overlayAuthor" type="text" placeholder="æ˜µç§°ï¼ˆå¯é€‰ï¼‰" maxlength="128">
            </div>
            <div class="row">
              <textarea id="overlayContent" placeholder="å†™ä¸‹ä½ çš„æƒ³æ³•..." maxlength="2000"></textarea>
            </div>
            <button id="overlaySubmit" type="submit">æäº¤</button>
          </form>
        </div>
      </div>
    </div>

    <!-- åº•éƒ¨å¸¸è§„è¯„è®ºè¡¨å•ï¼ˆé¦–æ¬¡éšè—ï¼Œæäº¤ç¬¬ä¸€æ¡åæ˜¾ç¤ºï¼Œä¾¿äºç»§ç»­è¯„è®ºï¼‰ -->
    <form id="commentForm">
      <input id="author" type="text" placeholder="æ˜µç§°ï¼ˆå¯é€‰ï¼‰" maxlength="128">
      <textarea id="content" placeholder="è¯´ç‚¹ä»€ä¹ˆ..." maxlength="2000"></textarea>
      <button id="submitBtn" type="submit">æäº¤</button>
    </form>

    <!-- çŠ¶æ€åŒºåŸŸï¼šå»æ‰é»˜è®¤â€œå°šæœªåŠ è½½â€ -->
    <div id="status"></div>
    <div id="list"></div>
    <div style="margin-top:12px;">
      <button id="moreBtn" style="background:#555;">åŠ è½½æ›´å¤š</button>
    </div>
    <!-- çˆ±å¿ƒè¯äº‘æŒ‰é’®ä¸ç”»å¸ƒ -->
    <div id="wcWrap">
      <button id="wcBtn" style="background:#2962ff;">ç”Ÿæˆè¯äº‘</button>
      <canvas id="wordcloudCanvas"></canvas>
    </div>
    <div id="wordcloud"></div>
  </div>

  <script>
    // å˜é‡ä¸å…ƒç´ å¼•ç”¨
    const playBtn = document.getElementById('playBtn');
    const videoWrap = document.getElementById('videoWrap');
    const video = document.getElementById('video');
    const danmakuLayer = document.getElementById('danmakuLayer');

    const overlay = document.getElementById('overlay');
    const overlayForm = document.getElementById('overlayForm');
    const overlayAuthorEl = document.getElementById('overlayAuthor');
    const overlayContentEl = document.getElementById('overlayContent');
    const overlaySubmitBtn = document.getElementById('overlaySubmit');

    const formEl = document.getElementById('commentForm');
    const authorEl = document.getElementById('author');
    const contentEl = document.getElementById('content');
    const submitBtn = document.getElementById('submitBtn');

    const statusEl = document.getElementById('status');
    const listEl = document.getElementById('list');
    const moreBtn = document.getElementById('moreBtn');

    // çŠ¶æ€
    const thread = (location.pathname.replace(/[^a-z0-9/_-]/gi, '_') || '/').toLowerCase();
    let offset = 0, limit = 20, loading = false, done = false;
    let dmIndexBySec = new Map();
    let shownById = new Set();
    let danmakuEnabled = false; // é¦–æ¬¡ä¸å±•ç¤ºå†å²å¼¹å¹•ï¼Œè¯„è®ºæˆåŠŸåå¼€å¯

    // æ’­æ”¾æŒ‰é’®
    playBtn.addEventListener('click', () => {
      playBtn.style.display = 'none';
      videoWrap.style.display = 'block';
      video.play().catch(() => {});
    });

    // è§†é¢‘ç»“æŸï¼šæ˜¾ç¤ºå±…ä¸­å¼¹çª—
    video.addEventListener('ended', () => {
      overlay.style.display = 'flex';
    });

    // å¼¹çª—æäº¤è¯„è®º
    overlayForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const author = overlayAuthorEl.value.trim();
      const content = overlayContentEl.value.trim();
      if (!content) { alert('å†…å®¹ä¸èƒ½ä¸ºç©º'); return; }
      overlaySubmitBtn.disabled = true;
      try {
        const at = Math.floor(video.currentTime || 0);
        const resp = await fetch('/comments', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ thread, author, content, at_seconds: at })
        });
        const data = await resp.json();
        if (!resp.ok || !data.ok) throw new Error(data.error || 'æäº¤å¤±è´¥');

        // å±•ç¤ºè‡ªå·±åˆšæäº¤çš„è¯„è®ºä¸å¼¹å¹•
        listEl.insertAdjacentHTML('afterbegin', renderItem(data.item));
        overlayContentEl.value = '';
        statusEl.textContent = 'æäº¤æˆåŠŸ';
        showDanmakuNow(data.item);

        // éšè—å¼¹çª—ï¼Œå±•ç¤ºè¯„è®ºä¸å†å²å¼¹å¹•ï¼Œå¹¶æ˜¾ç¤ºåº•éƒ¨å¸¸è§„è¡¨å•ä»¥ä¾¿ç»§ç»­è¯„è®º
        overlay.style.display = 'none';
        formEl.style.display = 'flex';
        revealCommentsAndDanmaku();
      } catch (err) {
        alert('æäº¤å¤±è´¥ï¼š' + (err.message || err));
      } finally {
        overlaySubmitBtn.disabled = false;
      }
    });

    // åº•éƒ¨å¸¸è§„è¡¨å•ï¼Œç»§ç»­è¯„è®ºï¼ˆå¯é€‰ï¼Œä¸å½±å“é¦–æ¬¡ gatingï¼‰
    formEl.addEventListener('submit', async (e) => {
      e.preventDefault();
      const author = authorEl.value.trim();
      const content = contentEl.value.trim();
      if (!content) { alert('å†…å®¹ä¸èƒ½ä¸ºç©º'); return; }
      submitBtn.disabled = true;
      try {
        const at = Math.floor(video.currentTime || 0);
        const resp = await fetch('/comments', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ thread, author, content, at_seconds: at })
        });
        const data = await resp.json();
        if (!resp.ok || !data.ok) throw new Error(data.error || 'æäº¤å¤±è´¥');

        listEl.insertAdjacentHTML('afterbegin', renderItem(data.item));
        contentEl.value = '';
        statusEl.textContent = 'æäº¤æˆåŠŸ';
        showDanmakuNow(data.item);
      } catch (err) {
        statusEl.textContent = 'æäº¤å¤±è´¥ï¼š' + (err.message || err);
      } finally {
        submitBtn.disabled = false;
      }
    });

    // åŠ è½½æ›´å¤š
    moreBtn.addEventListener('click', () => {
      if (done || loading) return;
      loadComments();
    });

    // æ‹‰å–è¯„è®ºå¹¶å»ºç«‹å¼¹å¹•ç´¢å¼•ï¼ˆä»…åœ¨å±•ç¤ºåä½¿ç”¨ï¼‰
    async function loadComments() {
      loading = true;
      statusEl.textContent = 'æ­£åœ¨åŠ è½½è¯„è®º...';
      try {
        const resp = await fetch(`/comments?thread=${encodeURIComponent(thread)}&limit=${limit}&offset=${offset}`);
        const data = await resp.json();
        if (!resp.ok || !data.ok) throw new Error(data.error || 'æ‹‰å–å¤±è´¥');
        if (data.items.length === 0) { done = true; moreBtn.disabled = true; statusEl.textContent = 'æ²¡æœ‰æ›´å¤šäº†'; return; }
        data.items.forEach(item => {
          if (!document.querySelector(`.item[data-id="${item.id}"]`)) {
            listEl.insertAdjacentHTML('beforeend', renderItem(item));
          }
          if (Number.isFinite(item.at_seconds)) {
            const sec = item.at_seconds;
            if (!dmIndexBySec.has(sec)) dmIndexBySec.set(sec, []);
            dmIndexBySec.get(sec).push(item);
          }
        });
        offset += data.items.length;
        statusEl.textContent = `å·²åŠ è½½ ${offset} æ¡`;
      } catch (err) {
        statusEl.textContent = 'åŠ è½½å¤±è´¥ï¼š' + (err.message || err);
      } finally {
        loading = false;
      }
    }

    // ç‚¹èµäº‹ä»¶ä»£ç†
    listEl.addEventListener('click', async (e) => {
      const btn = e.target.closest('.likeBtn');
      if (!btn) return;

      const itemEl = btn.closest('.item');
      const id = Number(itemEl?.dataset?.id || 0);
      if (!id || isLiked(id)) return;

      btn.disabled = true;
      try {
        const resp = await fetch(`/comments/${id}/like`, { method: 'POST' });
        const data = await resp.json();
        if (!resp.ok || !data.ok) throw new Error(data.error || 'ç‚¹èµå¤±è´¥');

        const countEl = btn.querySelector('.likeCount');
        if (countEl) countEl.textContent = String(data.likes_count);
        localStorage.setItem('liked:' + id, '1');
      } catch (err) {
        btn.disabled = false;
        alert('ç‚¹èµå¤±è´¥ï¼š' + (err.message || err));
      }
    });

    // å·¥å…·å‡½æ•°ä¸æ¸²æŸ“
    function isLiked(id) {
      return localStorage.getItem('liked:' + id) === '1';
    }
    function renderItem(item) {
      const author = item.author ? escapeHtml(item.author) : 'åŒ¿å';
      const content = escapeHtml(item.content || '');
      const time = formatTime(item.created_at);
      const likedAttr = isLiked(item.id) ? 'disabled' : '';
      return `
        <div class="item" data-id="${item.id}">
          <div class="meta">${author} Â· ${time}
            <button class="likeBtn" ${likedAttr} title="ç‚¹èµ">
              ğŸ‘ <span class="likeCount">${item.likes_count || 0}</span>
            </button>
          </div>
          <div class="content">${content}</div>
        </div>
      `;
    }
    function escapeHtml(str) {
      return String(str).replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s]));
    }
    function formatTime(t) {
      try { return new Date(t).toLocaleString(); } catch { return String(t); }
    }

    function showDanmakuNow(item) {
      const y = pickY();
      const el = document.createElement('div');
      el.className = 'dm';
      el.style.top = y + 'px';
      el.textContent = item.content || '';
      danmakuLayer.appendChild(el);
      el.addEventListener('animationend', () => el.remove());
    }
    function pickY() {
      const h = danmakuLayer.clientHeight || 300;
      const lines = Math.max(6, Math.floor(h / 28));
      const line = Math.floor(Math.random() * lines);
      return Math.min(h - 24, Math.max(0, line * 24));
    }

    // å†å²å¼¹å¹•ä»…åœ¨å¼€å¯åæ’­æ”¾
    video.addEventListener('timeupdate', () => {
      if (!danmakuEnabled) return;
      const sec = Math.floor(video.currentTime || 0);
      const items = dmIndexBySec.get(sec) || [];
      items.forEach(item => {
        if (shownById.has(item.id)) return;
        shownById.add(item.id);
        showDanmakuNow(item);
      });
    });

    // æäº¤è¯„è®ºæˆåŠŸåï¼šå±•ç¤ºè¯„è®ºä¸å¼€å¯å†å²å¼¹å¹•
    function revealCommentsAndDanmaku() {
      listEl.style.display = 'block';
      moreBtn.style.display = 'inline-block';
      danmakuEnabled = true;
      offset = 0; done = false; dmIndexBySec.clear(); shownById.clear();
      // åŠ è½½è¯„è®ºåè‡ªåŠ¨ç”Ÿæˆä¸€æ¬¡è¯äº‘ï¼ˆçˆ±å¿ƒå½¢çŠ¶ï¼‰
      loadComments().then(() => genWordCloud(true)).catch(() => {});
    }

    // ä¿®å¤ï¼šç§»é™¤åŸæ¥è¯¯æ”¾å…¥çš„ CSSï¼ˆ#wcWrapã€#wordcloudCanvasï¼‰ï¼Œä»¥ä¸‹ä»…ä¿ç•™ JS ä»£ç 
    const wcWrap = document.getElementById('wcWrap');
    const wcBtn = document.getElementById('wcBtn');
    const wcCanvas = document.getElementById('wordcloudCanvas');
    
    wcBtn.addEventListener('click', () => genWordCloud(false));
    
    // ç”Ÿæˆè¯äº‘å…¥å£
    async function genWordCloud(auto = false) {
      try {
        statusEl.textContent = 'æ­£åœ¨ç”Ÿæˆè¯äº‘...';
        const tokens = await collectTokensFromAllComments();
        renderWordCloudHeart(tokens);
        statusEl.textContent = 'è¯äº‘å·²ç”Ÿæˆ';
        wcCanvas.style.display = 'block';
        if (!auto) wcCanvas.scrollIntoView({ behavior: 'smooth', block: 'center' });
      } catch (err) {
        statusEl.textContent = 'è¯äº‘ç”Ÿæˆå¤±è´¥ï¼š' + (err.message || err);
      }
    }
    
    // æ‹‰å–å…¨éƒ¨è¯„è®ºå¹¶ç»Ÿè®¡è¯é¢‘
    async function collectTokensFromAllComments() {
      let wcOffset = 0;
      const wcLimit = 100;
      const texts = [];
      while (true) {
        const resp = await fetch(`/comments?thread=${encodeURIComponent(thread)}&limit=${wcLimit}&offset=${wcOffset}`);
        const data = await resp.json();
        if (!resp.ok || !data.ok) throw new Error(data.error || 'æ‹‰å–å¤±è´¥');
        if (data.items.length === 0) break;
        texts.push(...data.items.map(i => String(i.content || '')));
        wcOffset += data.items.length;
        if (data.items.length < wcLimit) break;
      }
      return buildFrequencies(texts);
    }
    
    // ç®€æ˜“ä¸­æ–‡å‹å¥½åˆ†è¯ï¼šè‹±æ–‡æŒ‰è¯ã€ä¸­æ–‡ç”¨åŒå­—æ»‘çª—
    function buildFrequencies(texts) {
      const stop = new Set(['çš„','äº†','æ˜¯','æˆ‘','ä½ ','ä»–','å¥¹','å®ƒ','åœ¨','å’Œ','ä¸','å°±','éƒ½','å¾ˆ','ä¹Ÿ','è¿™','é‚£','ä¸€ä¸ª','æˆ‘ä»¬','ä»–ä»¬','å› ä¸º','æ‰€ä»¥','å¦‚æœ','ä½†æ˜¯','è€Œä¸”','ä¸æ˜¯','è¿˜æœ‰','ä¼š','èƒ½','æŠŠ','è¢«','ç»™','è®©','å‘¢','å˜›','å—','å•Š','å“¦','å‘ƒ']);
      const freq = new Map();
      const normalize = s => s.toLowerCase().replace(/[^\p{L}\p{N}\u4e00-\u9fff]+/gu, ' ');
      const add = w => {
        if (!w) return;
        if (stop.has(w)) return;
        if (w.length < 2) return;
        freq.set(w, (freq.get(w) || 0) + 1);
      };
      for (const t of texts) {
        const s = normalize(t);
        const words = s.match(/\p{L}[\p{L}\p{N}_]{1,}/gu) || [];
        words.forEach(add);
        const zhSeqs = s.match(/[\u4e00-\u9fff]+/g) || [];
        zhSeqs.forEach(seq => {
          if (seq.length >= 2) {
            for (let i = 0; i < seq.length - 1; i++) add(seq.slice(i, i + 2));
          }
        });
      }
      const arr = Array.from(freq.entries()).map(([word, count]) => ({ word, count }));
      arr.sort((a, b) => b.count - a.count);
      return arr.slice(0, 120); // å– Top 120
    }
    
    // åœ¨ canvas ä¸Šç»˜åˆ¶çˆ±å¿ƒå½¢çŠ¶è¯äº‘
    function renderWordCloudHeart(tokens) {
      const canvas = wcCanvas;
      const ctx = canvas.getContext('2d');
      const W = canvas.clientWidth || 900;
      const H = canvas.clientHeight || 420;
      canvas.width = W * window.devicePixelRatio;
      canvas.height = H * window.devicePixelRatio;
      ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
      ctx.clearRect(0, 0, W, H);
    
      // é…è‰²ä¸å¤§å°æ˜ å°„
      const palette = ['#e91e63','#f06292','#ff6b6b','#ff8e8e','#ffa6c9','#f48fb1','#ec407a','#ab47bc','#9c27b0','#ff4081'];
      const max = tokens.length ? tokens[0].count : 1;
      const min = tokens.length ? tokens[tokens.length - 1].count : 1;
      const fontSize = c => {
        const t = (c - min) / Math.max(1, (max - min));
        return Math.round(14 + t * 38); // 14px ~ 52px
      };
    
      // å¿ƒå½¢éšå¼æ–¹ç¨‹ï¼š(x^2 + y^2 - 1)^3 - x^2 y^3 <= 0ï¼Œåæ ‡åŸŸ [-1.3,1.3]
      const heartInside = (x, y) => {
        const a = x*x + y*y - 1;
        return (a*a*a - x*x*y*y*y) <= 0;
      };
    
      // ç®€å•ç¢°æ’æ£€æµ‹ï¼ˆæ ¼å­ï¼‰
      const cell = 18; // ç¢°æ’æ ¼å­åƒç´ 
      const cols = Math.ceil(W / cell), rows = Math.ceil(H / cell);
      const grid = Array.from({ length: rows }, () => Array(cols).fill(0));
      const occupy = (x, y, w, h) => {
        const c0 = Math.max(0, Math.floor(x / cell)), r0 = Math.max(0, Math.floor(y / cell));
        const c1 = Math.min(cols - 1, Math.floor((x + w) / cell)), r1 = Math.min(rows - 1, Math.floor((y + h) / cell));
        for (let r = r0; r <= r1; r++) for (let c = c0; c <= c1; c++) {
          if (grid[r][c]) return false;
        }
        for (let r = r0; r <= r1; r++) for (let c = c0; c <= c1; c++) grid[r][c] = 1;
        return true;
      };
    
      // ç”Ÿæˆçˆ±å¿ƒåŒºåŸŸå†…çš„éšæœºç‚¹ï¼ˆè¶Šæ¥è¿‘ä¸­å¿ƒè¯è¶Šå¤§ï¼‰
      const samplePoint = (bias = 0.5) => {
        // æ˜ å°„åˆ° [-1.3,1.3] åŒºåŸŸ
        for (let k = 0; k < 800; k++) {
          const rx = (Math.random() * 2 - 1) * 1.3;
          const ry = (Math.random() * 2 - 1) * 1.3;
          if (!heartInside(rx, ry)) continue;
          // åå‘ä¸­å¿ƒï¼ˆè®©å¤§è¯æ›´å®¹æ˜“é ä¸­å¿ƒï¼‰
          const s = Math.random();
          if (s < bias) {
            const rx2 = rx * 0.7, ry2 = ry * 0.7;
            if (heartInside(rx2, ry2)) { return { x: rx2, y: ry2 }; }
          }
          return { x: rx, y: ry };
        }
        return { x: 0, y: 0 };
      };
    
      // å°†å½’ä¸€åŒ–åæ ‡æ˜ å°„åˆ°ç”»å¸ƒåƒç´ ï¼ˆå±…ä¸­ï¼‰
      const toCanvas = (nx, ny) => {
        const m = Math.min(W, H);
        const cx = W / 2, cy = H / 2;
        const scale = m / 2.6; // è®©å¿ƒå½¢é“ºæ»¡ç”»å¸ƒ
        return { x: cx + nx * scale, y: cy - ny * scale };
      };
    
      // è¯æŒ‰å¤§å°æ’åºåå¸ƒå±€
      tokens.sort((a, b) => b.count - a.count);
      tokens.forEach((t, i) => {
        const size = fontSize(t.count);
        ctx.font = `bold ${size}px system-ui, -apple-system, Segoe UI, Arial`;
        const text = t.word;
        const w = Math.ceil(ctx.measureText(text).width);
        const h = Math.ceil(size * 1.2);
    
        // å¤§è¯æ›´é ä¸­å¿ƒï¼Œå°è¯æ›´å¤–å›´
        const bias = Math.min(0.85, 0.55 + i / tokens.length * 0.3);
        let placed = false;
        for (let tries = 0; tries < 200 && !placed; tries++) {
          const p = samplePoint(bias);
          const pos = toCanvas(p.x, p.y);
          const x = Math.round(pos.x - w / 2);
          const y = Math.round(pos.y - h / 2);
          if (x < 0 || y < 0 || x + w >= W || y + h >= H) continue;
          if (!occupy(x, y, w, h)) continue;
    
          ctx.save();
          ctx.fillStyle = palette[(i % palette.length)];
          ctx.globalAlpha = 0.85;
          ctx.fillText(text, x, y + h * 0.8);
          ctx.restore();
          placed = true;
        }
      });
    }
    // --- è¯äº‘é€»è¾‘ç»“æŸ ---
  </script>
</body>
</html>