<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>心形词云</title>
  <style>
    :root {
      color-scheme: dark;
    }
    html, body {
      width: 100vw;
      height: 100vh;
      margin: 0;
      padding: 0;
      background: #000; /* 统一黑色背景 */
      overflow: hidden;
    }
    #wcPage {
      width: 100vw;
      height: 100vh;
      display: grid;
      place-items: center;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }
    #wcPage .canvasWrap {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    canvas#wordcloudCanvas {
      width: 100vw;
      height: 100vh;
      display: block;
      /* 没有边框、没有圆角 */
    }
    /* 可选：加载中提示样式 */
    #loading {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      color: #ff2b2b;
      font: 600 16px system-ui, -apple-system, Segoe UI, Arial;
      letter-spacing: 0.5px;
    }
  </style>
</head>
<body>
  <div id="wcPage">
    <div class="canvasWrap">
      <canvas id="wordcloudCanvas"></canvas>
      <div id="loading">正在生成心形词云...</div>
    </div>
  </div>

  <script>
    // 设备像素比（适度限制到 2，避免过高导致性能问题）
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    const canvas = document.getElementById('wordcloudCanvas');
    const ctx = canvas.getContext('2d');
    const loadingEl = document.getElementById('loading');

    // 离屏画布用于掩模计算
    const maskCanvas = document.createElement('canvas');
    const maskCtx = maskCanvas.getContext('2d');

    let W = 0, H = 0;       // 画布像素尺寸（dpr 后）
    let mask = null;        // 二值掩模：1=心形黑色区域；0=其他

    function sizeCanvas() {
      W = Math.floor(window.innerWidth * dpr);
      H = Math.floor(window.innerHeight * dpr);
      canvas.width = W;
      canvas.height = H;
      maskCanvas.width = W;
      maskCanvas.height = H;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      maskCtx.setTransform(1, 0, 0, 1, 0, 0);
      // 背景填充为黑色
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);
    }

    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => resolve(img);
        img.onerror = (e) => reject(e);
        img.src = src;
      });
    }

    // 将图片按比例缩放并居中绘制到掩模画布上，留出 10% 边距
    function drawImageFit(img, marginRatio = 0.1) {
      maskCtx.clearRect(0, 0, W, H);
      const marginW = W * marginRatio;
      const marginH = H * marginRatio;
      const targetW = W - marginW * 2;
      const targetH = H - marginH * 2;
      const scale = Math.min(targetW / img.width, targetH / img.height);
      const drawW = Math.floor(img.width * scale);
      const drawH = Math.floor(img.height * scale);
      const dx = Math.floor((W - drawW) / 2);
      const dy = Math.floor((H - drawH) / 2);

      // 背景填充为黑色，确保白色仅来自图片白底
      maskCtx.fillStyle = '#000';
      maskCtx.fillRect(0, 0, W, H);

      maskCtx.drawImage(img, dx, dy, drawW, drawH);
      return { dx, dy, drawW, drawH };
    }

    // 仅识别“黑色像素”为心形区域；白色保留为缝隙
    function makeBlackMask() {
      const { data } = maskCtx.getImageData(0, 0, W, H);
      const out = new Uint8Array(W * H);
      let insideCount = 0;

      for (let i = 0, p = 0; i < data.length; i += 4, p++) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const a = data[i + 3];
        // 感知亮度（Y），以及 RGB 同时偏低的灰/黑
        const Y = 0.2126 * r + 0.7152 * g + 0.0722 * b;

        const isBlackish = a >= 20 && (Y <= 140 || (r <= 130 && g <= 130 && b <= 130));
        out[p] = isBlackish ? 1 : 0;
        if (isBlackish) insideCount++;
      }

      // 如果识别结果过少（可能阈值仍偏紧），柔性放宽一次（仍只识别深灰/黑）
      if (insideCount < (W * H * 0.02)) {
        for (let i = 0, p = 0; i < data.length; i += 4, p++) {
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          const a = data[i + 3];
          const Y = 0.2126 * r + 0.7152 * g + 0.0722 * b;
          out[p] = a >= 20 && (Y <= 165 || (r <= 150 && g <= 150 && b <= 150)) ? 1 : 0;
        }
      }
      return out;
    }

    // 构建词频（扩大到 400），中文计入“双字滑窗 + 单字”
    function buildFrequencies(texts) {
      const stop = new Set(['的','了','是','我','你','他','她','它','在','和','与','就','都','很','也','这','那','一个','我们','他们','因为','所以','如果','但是','而且','不是','还有','会','能','把','被','给','让','呢','嘛','吗','啊','哦','呃']);
      const freq = new Map();
      const normalize = s => s.toLowerCase().replace(/[^\p{L}\p{N}\u4e00-\u9fff]+/gu, ' ');
      const add = w => { if (!w || stop.has(w)) return; freq.set(w, (freq.get(w) || 0) + 1); };

      for (const t of texts) {
        const s = normalize(t);
        // 英文词（≥2字符）
        const words = s.match(/\p{L}[\p{L}\p{N}_]{1,}/gu) || [];
        words.forEach(add);

        // 中文序列：双字滑窗 + 单字
        const zhSeqs = s.match(/[\u4e00-\u9fff]+/g) || [];
        zhSeqs.forEach(seq => {
          if (seq.length >= 2) {
            for (let i = 0; i < seq.length - 1; i++) add(seq.slice(i, i + 2));
          }
          for (let i = 0; i < seq.length; i++) add(seq.slice(i, i + 1));
        });
      }
      const arr = Array.from(freq.entries()).map(([word, count]) => ({ word, count }));
      arr.sort((a, b) => b.count - a.count);
      return arr.slice(0, 400);
    }

    // 词云布局与绘制（更激进填充）
    async function renderWordCloudMask(tokens) {
      // 背景清空为黑色
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      const inside = (x, y) => (x >= 0 && y >= 0 && x < W && y < H && mask[y * W + x] === 1);

      // 更紧凑网格与覆盖率
      const cell = 8; // 更小网格以提升贴合度
      const cols = Math.ceil(W / cell), rows = Math.ceil(H / cell);
      const grid = Array.from({ length: rows }, () => Array(cols).fill(0));     // 碰撞占位
      const covered = Array.from({ length: rows }, () => Array(cols).fill(0));  // 覆盖统计

      let shapeCells = 0;
      for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) {
        const cx = Math.floor(c * cell + cell / 2);
        const cy = Math.floor(r * cell + cell / 2);
        if (inside(cx, cy)) shapeCells++;
      }

      const occupy = (x, y, w, h) => {
        const pad = 1; // 收缩 1px 允许更贴近但不重叠
        const c0 = Math.max(0, Math.floor((x + pad) / cell));
        const r0 = Math.max(0, Math.floor((y + pad) / cell));
        const c1 = Math.min(cols - 1, Math.floor((x + w - pad) / cell));
        const r1 = Math.min(rows - 1, Math.floor((y + h - pad) / cell));
        for (let r = r0; r <= r1; r++) for (let c = c0; c <= c1; c++) { if (grid[r][c]) return false; }
        for (let r = r0; r <= r1; r++) for (let c = c0; c <= c1; c++) { grid[r][c] = 1; covered[r][c] = 1; }
        return true;
      };
      const coverageRatio = () => {
        let coveredCells = 0;
        for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) if (covered[r][c]) coveredCells++;
        return shapeCells ? coveredCells / shapeCells : 0;
      };

      const brightRed = '#FF2B2B';
      const maxC = tokens.length ? tokens[0].count : 1;
      const minC = tokens.length ? tokens[tokens.length - 1].count : 1;
      const fontSize = c => {
        const t = (c - minC) / Math.max(1, (maxC - minC));
        return Math.round(18 + t * 50); // 18px ~ 68px
      };

      function sampleInside() {
        for (let k = 0; k < 1500; k++) {
          const x = Math.floor(Math.random() * W);
          const y = Math.floor(Math.random() * H);
          if (inside(x, y)) return { x, y };
        }
        return { x: Math.floor(W / 2), y: Math.floor(H / 2) };
      }
      // 缝隙优先采样：优先从未覆盖格子的中心点开始尝试
      function sampleGap() {
        for (let tries = 0; tries < 1200; tries++) {
          const c = Math.floor(Math.random() * cols);
          const r = Math.floor(Math.random() * rows);
          if (!covered[r][c]) {
            const x = Math.floor(c * cell + cell / 2);
            const y = Math.floor(r * cell + cell / 2);
            if (inside(x, y)) return { x, y };
          }
        }
        return sampleInside();
      }

      // 第一阶段：按词频从大到小布局
      tokens.sort((a, b) => b.count - a.count);
      let placedCount = 0;

      tokens.forEach((t) => {
        const size = fontSize(t.count);
        ctx.font = `bold ${size}px system-ui, -apple-system, Segoe UI, Arial`;
        const text = t.word;
        const w = Math.ceil(ctx.measureText(text).width);
        const h = Math.ceil(size * 1.03); // 垂直占位更紧凑
        let placed = false;

        for (let tries = 0; tries < 320 && !placed; tries++) {
          const p = sampleInside();
          const x = Math.round(p.x - w / 2);
          const y = Math.round(p.y - h / 2);
          if (x < 0 || y < 0 || x + w >= W || y + h >= H) continue;
          // corners must be inside to避免越界到白色缝隙
          if (!inside(p.x, p.y) || !inside(x, y) || !inside(x + w, y) || !inside(x, y + h) || !inside(x + w, y + h)) continue;
          if (!occupy(x, y, w, h)) continue;

          ctx.fillStyle = brightRed;
          ctx.fillText(text, x, y + h * 0.86); // 基线微调，减少上下留白
          placed = true;
          placedCount++;
        }
      });

      // 兜底：若没有任何词成功放置，用“爱”填满黑色区域，避免空画面
      if (placedCount === 0) {
        const text = '爱';
        for (let i = 0; i < 360; i++) {
          const size = 24 + Math.floor(Math.random() * 36);
          ctx.font = `bold ${size}px system-ui, -apple-system, Segoe UI, Arial`;
          const w = Math.ceil(ctx.measureText(text).width);
          const h = Math.ceil(size * 1.03);
          let placed = false;

          for (let tries = 0; tries < 280 && !placed; tries++) {
            const p = sampleInside();
            const x = Math.round(p.x - w / 2);
            const y = Math.round(p.y - h / 2);
            if (x < 0 || y < 0 || x + w >= W || y + h >= H) continue;
            if (!inside(p.x, p.y) || !inside(x, y) || !inside(x + w, y) || !inside(x, y + h) || !inside(x + w, y + h)) continue;
            if (!occupy(x, y, w, h)) continue;

            ctx.fillStyle = brightRed;
            ctx.fillText(text, x, y + h * 0.86);
            placed = true;
          }
        }
      }

      // 第二阶段：更强填缝策略
      const target = 0.98; // 更高覆盖率
      const topWords = tokens.slice(0, Math.min(40, tokens.length)).map(t => t.word); // 更多重复词
      let fillRounds = 0;

      while (coverageRatio() < target && fillRounds < 12) { // 轮次更足
        for (let k = 0; k < topWords.length; k++) {
          const text = topWords[k];
          const size = Math.max(8, 18 - fillRounds * 2); // 最小字号降到 8px
          ctx.font = `bold ${size}px system-ui, -apple-system, Segoe UI, Arial`;
          const w = Math.ceil(ctx.measureText(text).width);
          const h = Math.ceil(size * 1.03);
          let placed = false;

          for (let tries = 0; tries < 280 && !placed; tries++) {
            const p = sampleGap();
            const x = Math.round(p.x - w / 2);
            const y = Math.round(p.y - h / 2);
            if (x < 0 || y < 0 || x + w >= W || y + h >= H) continue;
            if (!inside(p.x, p.y)) continue;
            if (!occupy(x, y, w, h)) continue;

            ctx.fillStyle = brightRed;
            ctx.fillText(text, x, y + h * 0.86);
            placed = true;
          }
        }
        fillRounds++;
      }

      // 移除加载提示
      loadingEl.style.display = 'none';
    }

    // 示例：内置少量文本，若实际有评论数据可替换为真实文本数组
    function getSeedTexts() {
      return [
        '心跳', '热爱', '你', '我', '在一起', '永远', '喜欢你', '甜蜜', '浪漫', '相遇',
        '守护', '陪伴', '珍惜', '回忆', '告白', '幸福', '温暖', '赤诚', '热烈', '牵挂',
        '思念', '期待', '缘分', '勇敢', '惊喜', '微笑', '拥抱', '亲密', '真心', '初见',
        '余生', '只想', '你和我', '不放弃', '更靠近', '心动', '怦然', '心事', '爱的形状', '心的节奏',
        '世界', '只剩你', '我的光', '你的眼睛', '温柔', '坚定', '向往', '此刻', '永恒', '未来'
      ];
    }

    async function main() {
      sizeCanvas();

      let img;
      try {
        img = await loadImage('心跳.png');
      } catch (e) {
        console.error('心跳.png 加载失败：', e);
        // 若图片失败，仍显示纯黑背景 + 兜底“爱”
        maskCtx.fillStyle = '#000';
        maskCtx.fillRect(0, 0, W, H);
      }

      if (img) drawImageFit(img, 0.10);
      mask = makeBlackMask();

      // 构造词频（若实际数据可替换 getSeedTexts）
      const texts = getSeedTexts();
      const tokens = buildFrequencies(texts);

      await renderWordCloudMask(tokens);
    }

    // 可选：窗口尺寸变化时，节流重绘
    let resizeTimer = null;
    window.addEventListener('resize', () => {
      if (resizeTimer) clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        loadingEl.style.display = 'block';
        main();
      }, 200);
    });

    // 启动
    document.addEventListener('DOMContentLoaded', main);
  </script>
</body>
</html>